복습 1.
부하를 먹는 부분에서 정확하게 파악하는 것이 중요!

serverpacket 부분을 지우고 다시 빌드를 하면 복원이 되는데 이 부분이 중요!

패킷 설계만 하면 자동으로 만들어줌.

cpu를 여러가지로 나누는것을 식당에서 알바라고 비유할 수 있음

쓰레드에서 블로킹 함수를 호출하면 어떤 문제가 발생? -> 무조건 기다려야하는 일에서 문제가 발생하는데 db처리 하는것은 블로킹 형식으로 만든다. 

배그는 데디서버긴 하지만, 하나로 관리를 해서(싱글 쓰레드) 최대 100명임.

복습 2.
쓰레드를 만들 줄 알아야함. 서버 프로그래밍 시험문제에서 쓰레드와 종합해서 나오는 문제도 나올 수 있음

쓰레드가 하나의 영혼이라고 볼 수 있음

그 중에서 공유하는 메모리는 힙, 데이터이다.  스택은 각기 다른 걸 사용.

힙, 데이터, 스택을 0.1초만에 알아차릴 수 있어야한다.

더하고 빼고가 그대로 상쇄되는것이 아니라 단계가 더해지고 적용이 되고 빼기가 되기 때문에 뭔가 그대로 0으로 되지 않음.

lock_guard를 사용하면 lock, unlock을 굳이 안해도 저절로 됨.

스마트포인터는 쓰레드세이프 한것인가?
-> 레퍼런스 카운팅에서는 안전하긴 하지만 대입을 하는 경우에는 안전하지가 않다. 결론적으로는 안전하지 않다.

복습 3.
각기 다른 요청이 들어왔을때 동시다발적으로 처리를 못해줌.

command pattern 순차적으로 해결함.

functor의 역할이 중요함. 일반적인 함수 포인터와 functor를 비교하면 functor가 상위 호환임.

순차적으로 실행할때는 queue를 사용하는 것이 좋음.

패킷이 너무 많을 때 람다를 사용해서 대체할 수 있음.

메모리 풀링을 해버리면 나중에 오류 났을때 찾기가 힘들어짐.

요즘에는 풀링을 많이 사용하지 않는 추세임.

스마트포인터에서 핵심은 ref count이다. (ref count란 해당 메모리를 참조하는 포인터가 몇개인지 나타내는 값)

복습 4.
블로킹 계열의 함수를 사용하면 게임을 만들기 어려움.

stp같이 프로토콜이 명확할때는 블로킹 함수가 어울림.

워커쓰레드의 개수는 보통 cpu 개수의 1.5배이다.

db만 따로 빼고 나머지애들은 한번에 만듦.

bind, listen, accept 순.

socket을 통해 클라와 통신.

모든 걸 모아둔 것을 세션이라고 함.(강의에서는 대사관에 비유)

세션을 묶어서 세션 매니저로 관리하는게 일반적.

tcp의 특징 : 패킷하나를 보내더라도 잘려서 올 수있음

recv버퍼는 위치적으로 당연히 세션에 위치해야함.

recv버퍼를 커서를 옮기는 방식으로 사용하면 편함.

send버퍼는 더 생각할 게 많은데 만들어준 정보를 보내야해서 좀 어려움. 내용이 중첩되서 쌓이는 느낌임. 그렇기에 포인터처럼 각기 정보를 꽂아주는게 편함. send버퍼의 위치는 멀티쓰레드를 고려해서 만들어야 함.

언리얼을 만들때 윈속을 사용하는 것은 비추.


복습 1.
부하를 먹는 부분에서 정확하게 파악하는 것이 중요!

serverpacket 부분을 지우고 다시 빌드를 하면 복원이 되는데 이 부분이 중요!

패킷 설계만 하면 자동으로 만들어줌.

cpu를 여러가지로 나누는것을 식당에서 알바라고 비유할 수 있음

쓰레드에서 블로킹 함수를 호출하면 어떤 문제가 발생? -> 무조건 기다려야하는 일에서 문제가 발생하는데 db처리 하는것은 블로킹 형식으로 만든다. 

배그는 데디서버긴 하지만, 하나로 관리를 해서(싱글 쓰레드) 최대 100명임.

복습 2.
쓰레드를 만들 줄 알아야함. 서버 프로그래밍 시험문제에서 쓰레드와 종합해서 나오는 문제도 나올 수 있음

쓰레드가 하나의 영혼이라고 볼 수 있음

그 중에서 공유하는 메모리는 힙, 데이터이다.  스택은 각기 다른 걸 사용.

힙, 데이터, 스택을 0.1초만에 알아차릴 수 있어야한다.

더하고 빼고가 그대로 상쇄되는것이 아니라 단계가 더해지고 적용이 되고 빼기가 되기 때문에 뭔가 그대로 0으로 되지 않음.

lock_guard를 사용하면 lock, unlock을 굳이 안해도 저절로 됨.

스마트포인터는 쓰레드세이프 한것인가?
-> 레퍼런스 카운팅에서는 안전하긴 하지만 대입을 하는 경우에는 안전하지가 않다. 결론적으로는 안전하지 않다.

복습 3.
각기 다른 요청이 들어왔을때 동시다발적으로 처리를 못해줌.

command pattern 순차적으로 해결함.

functor의 역할이 중요함. 일반적인 함수 포인터와 functor를 비교하면 functor가 상위 호환임.

순차적으로 실행할때는 queue를 사용하는 것이 좋음.

패킷이 너무 많을 때 람다를 사용해서 대체할 수 있음.

메모리 풀링을 해버리면 나중에 오류 났을때 찾기가 힘들어짐.

요즘에는 풀링을 많이 사용하지 않는 추세임.

스마트포인터에서 핵심은 ref count이다. (ref count란 해당 메모리를 참조하는 포인터가 몇개인지 나타내는 값)

